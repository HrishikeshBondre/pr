<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<h3>exp 2 utilizing py libraries</h3>
    <pre>

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

data = {'Hours': [1,2,3,4,5], 'Marks': [10,20,30,40,50]}
df = pd.DataFrame(data)

print("Dataset:\n", df)

X = df[['Hours']]
y = df['Marks']

model = LinearRegression()
model.fit(X, y)

predicted = model.predict(pd.DataFrame({'Hours':[6]}))
print("Predicted marks for 6 hours:", predicted[0])

plt.scatter(X, y, color='blue')
plt.plot(X, model.predict(X), color='red')
plt.title("Hours vs Marks")
plt.xlabel("Hours Studied")
plt.ylabel("Marks Obtained")
plt.grid(True)
plt.show()


    </para>




    <h3>BFS</h3>
    <pre>

from collections import deque

graph = {}

n = int(input("Enter number of nodes: "))
for i in range(n):
    node = input(f"Enter node {i+1}: ")
    neighbors = input(f"Enter neighbors of {node} (space separated): ").split()
    graph[node] = neighbors

start_node = input("Enter starting node: ")

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node, end=" ")

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

print("\nBFS Traversal:")
bfs(graph, start_node)


    </para>



    <h3>DFS</h3>
  <pre><code>
graph = {}
visited = set()

n = int(input("Enter number of nodes: "))
for i in range(n):
    node = input(f"Enter node {i+1}: ")
    neighbors = input(f"Enter neighbors of {node} (space separated): ").split()
    graph[node] = neighbors

start_node = input("Enter starting node: ")


def dfs(visited, graph, node):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)

        for neighbor in graph[node]:
            dfs(visited, graph, neighbor)

print("\nDFS Traversal:")
dfs(visited, graph, start_node)

  </code></pre>



    <h3>GBFS</h3>

    <pre>
<code>
graph = {}
heuristics = {}

n = int(input("Enter number of nodes: "))
for i in range(n):
    node = input(f"Enter node {i + 1}: ")
    neighbors = input(f"Enter neighbors of {node} (space separated): ").split()
    graph[node] = neighbors
    heuristics[node] = int(input(f"Enter heuristic value for {node}: "))

start = input("Enter starting node: ")
goal = input("Enter goal node: ")

visited = set()
queue = [(heuristics[start], start)]

print("\nGBFS Traversal:")

while queue:
    queue.sort()
    h, node = queue.pop(0)

    if node not in visited:
        print(node, end=" -> " if node != goal else "\n")
        visited.add(node)
        if node == goal:
            print(f"Goal '{goal}' reached!")
            break
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append((heuristics[neighbor], neighbor))
  </code>
    </pre>


    <h3>A*</h3>
    <pre>
<code>
graph = {}
costs = {}
heuristics = {}

n = int(input("Enter number of nodes: "))
for _ in range(n):
    node = input("Enter node: ")
    neighbors = input(f"Enter neighbors of {node} (space separated): ").split()
    graph[node] = neighbors
    costs[node] = {}
    for neighbor in neighbors:
        costs[node][neighbor] = int(input(f"Cost from {node} to {neighbor}: "))
    heuristics[node] = int(input(f"Heuristic for {node}: "))

start = input("Enter start node: ")
goal = input("Enter goal node: ")

open_list = [(heuristics[start], 0, start)]
visited = set()

print("\nA* Traversal:")

while open_list:
    open_list.sort()
    f, g, node = open_list.pop(0)
    if node not in visited:
        print(node, end=" -> " if node != goal else "\n")
        visited.add(node)
        if node == goal:
            print(f"Goal '{goal}' reached!")
            break
        for neighbor in graph[node]:
            if neighbor not in visited:
                g_new = g + costs[node][neighbor]
                f_new = g_new + heuristics[neighbor]
                open_list.append((f_new, g_new, neighbor))

  </code>

    </pre>


    <h3>Train and Test Dataset</h3>
    <pre>
<code>
from sklearn.model_selection import train_test_split
import pandas as pd

n = int(input("Enter number of records: "))

ages = []
salaries = []
purchases = []

for i in range(n):
    print(f"\nEnter details for record {i+1}:")
    age = int(input("Enter Age: "))
    salary = int(input("Enter Salary: "))
    purchase = input("Purchased (Yes/No): ")

    ages.append(age)
    salaries.append(salary)
    purchases.append(purchase)

df = pd.DataFrame({
    'Age': ages,
    'Salary': salaries,
    'Purchased': purchases
})

print("\nOriginal Dataset:")
print(df)

X = df[['Age', 'Salary']]
y = df['Purchased']

test_ratio = float(input("\nEnter test size (e.g. 0.3 for 30% test data): "))

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_ratio, random_state=1)

print("\nTraining Set:")
print(X_train)

print("\nTesting Set:")
print(X_test)

  </code>

    </pre>

    <h3>Chatbot: Ans & Que</h3>
    <pre>
<code>
import json
import sys

print("ðŸ¤– Hello! Iâ€™m PyBot â€” your friendly chatbot.")
print("Type 'bye' anytime to exit.\n")

try:
    with open("memory.txt", "r") as file:
        responses = json.load(file)
except:
    responses = {
        "hi": "Hello there! ",
        "hello": "Hey! How are you doing today?",
        "how are you": "I'm great! How about you?",
        "your name": "I'm PyBot, your chat buddy! ðŸ¤–",
        "who created you": "I was created by a Python programmer!",
        "what can you do": "I can chat with you, learn new things, and remember them!",
        "thank you": "You're most welcome! ",
        "bye": "Goodbye! Have a great day! "
    }

def learn_new_response(user_input):
    print("Bot: I don't know how to respond to that. Can you teach me?")
    new_reply = input("You can say: ")
    responses[user_input] = new_reply
    print("Bot: Got it! I'll remember that. ")

def exit_chat():
    print("Bot:", responses.get("bye", "Goodbye! "))
    with open("memory.txt", "w") as file:
        json.dump(responses, file)
    print(" Chat memory saved successfully!")
    sys.exit()

while True:
    user_input = input("You: ").lower().strip()

    actions = {
        "bye": exit_chat,
        "default": lambda: (
            print("Bot:", responses[user_input])
            if user_input in responses
            else learn_new_response(user_input)
        )
    }

    (actions.get(user_input, actions["default"]))()

  </code>

    </pre>

    <h3>Simple Linear Regression</h3>
    <pre>
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

data = pd.DataFrame({
    'Name': ['Aakash', 'Priya', 'Rohan', 'Sneha', 'Karan'],
    'Age': [23, 25, 27, 30, 35],
    'Experience': [1, 2, 3, 5, 8],
    'Salary': [25000, 28000, 32000, 40000, 55000]
})

print("Dataset Preview:")
print(data)

X = data[['Experience']]
y = data['Salary']

model = LinearRegression()
model.fit(X, y)

y_pred = model.predict(X)

print("\nSlope (m):", model.coef_[0])
print("Intercept (c):", model.intercept_)

print("\nMean Squared Error:", mean_squared_error(y, y_pred))
print("RÂ² Score:", r2_score(y, y_pred))

plt.scatter(X, y, color='blue', label='Actual Data')
plt.plot(X, y_pred, color='red', label='Regression Line')
plt.xlabel('Experience (Years)')
plt.ylabel('Salary (â‚¹)')
plt.title('Simple Linear Regression: Experience vs Salary')
plt.legend()
plt.show()

</pre>


<h3>Multiple Linear Regression</h3>
    <pre>
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import matplotlib.pyplot as plt

data = pd.DataFrame({
    'Age': [22, 25, 28, 30, 35, 40, 45, 50, 55, 60],
    'Experience': [1, 2, 3, 5, 7, 10, 12, 15, 18, 20],
    'Gender': ['Male', 'Female', 'Female', 'Male', 'Male', 'Female', 'Male', 'Female', 'Male', 'Female'],
    'Salary': [25000, 28000, 35000, 40000, 48000, 55000, 60000, 65000, 70000, 75000]
})

print("Dataset Preview:")
print(data)

data['Gender'] = data['Gender'].map({'Male': 1, 'Female': 0})

X = data[['Age', 'Experience', 'Gender']]
y = data['Salary']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

model = LinearRegression()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

print("\nIntercept (b0):", model.intercept_)
print("Coefficients (b1, b2, b3):", model.coef_)

print("\nMean Squared Error:", mean_squared_error(y_test, y_pred))
print("RÂ² Score:", r2_score(y_test, y_pred))

plt.scatter(y_test, y_pred, color='blue')
plt.plot([y.min(), y.max()], [y.min(), y.max()], color='red', linestyle='--')
plt.xlabel('Actual Salary')
plt.ylabel('Predicted Salary')
plt.title('Multiple Regression: Actual vs Predicted Salary')
plt.show()

</pre>

<h3>Cross validation score : IRIS</h3>
    <pre>
from sklearn.datasets import load_iris
from sklearn.model_selection import cross_val_score, KFold
from sklearn.linear_model import LogisticRegression
import numpy as np

data = load_iris()
X = data.data
y = data.target

model = LogisticRegression(max_iter=200)

kf = KFold(n_splits=5, shuffle=True, random_state=1)

scores = cross_val_score(model, X, y, cv=kf)

print("Scores for each fold:", scores)
print("Average Score:", np.mean(scores))


</pre>


<h3>Confusion Matrix</h3>
    <pre>
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
import seaborn as sns
import matplotlib.pyplot as plt

iris = load_iris()
X = iris.data
y = iris.target

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = LogisticRegression(max_iter=200)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:\n", cm)

sns.heatmap(cm, annot=True, cmap='Blues', fmt='d',
            xticklabels=iris.target_names, yticklabels=iris.target_names)
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred, average='macro')
recall = recall_score(y_test, y_pred, average='macro')
f1 = f1_score(y_test, y_pred, average='macro')

print("Accuracy:", round(accuracy, 3))
print("Precision:", round(precision, 3))
print("Recall:", round(recall, 3))
print("F1-Score:", round(f1, 3))



</pre>

<h3>exp 9a credit card fraud detection</h3>
    <pre>

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score

data = pd.DataFrame({
    "Time": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0],
    "V1": [-1.3598, 1.1918, -1.3584, -0.9663, -1.1582, -0.4259, 1.2296, -0.1010, -0.3390, 1.6763, 1.12, -0.75],
    "V2": [-0.0728, 0.2662, -1.3401, -0.1850, 0.8777, -0.3957, 0.1410, 0.4656, 1.1196, 0.7630, 0.58, -1.02],
    "V3": [2.5363, 0.1665, 1.7732, 1.7929, 1.5487, 2.3900, 0.0450, 1.8745, 1.0443, 0.2719, 2.11, 1.67],
    "Amount": [149.62, 2.69, 378.66, 123.50, 69.99, 3.67, 0.76, 7.80, 9.99, 1.00, 98.00, 25.00],
    "Class": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]
})

print("Dataset Created Successfully\n")

scaler = StandardScaler()
data[['Amount', 'Time']] = scaler.fit_transform(data[['Amount', 'Time']])

X = data.drop('Class', axis=1)
y = data['Class']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)

model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

# Step 6: Evaluate Model (No warnings)
print(" Model Evaluation Results\n")
print("Accuracy:", round(accuracy_score(y_test, y_pred) * 100, 2), "%\n")
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred, labels=[0, 1]))
print("\nClassification Report:\n", classification_report(y_test, y_pred, labels=[0, 1]))



    </para>

    <h3>exp 9b NLP Dataset</h3>
    <pre>

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Step 1: Create Dataset Manually
data = pd.DataFrame({
    "tweet": [
        "I love this new phone, itâ€™s amazing!",
        "Worst service ever! Totally disappointed.",
        "The weather is okay today.",
        "So happy with the results!",
        "I hate traffic jams.",
        "Just finished my coffee. Feeling good.",
        "This movie was terrible.",
        "Such a beautiful day!",
        "The food was average, nothing special.",
        "Iâ€™m feeling sad today.",
        "Best experience ever!",
        "This laptop is slow and annoying.",
        "I absolutely adore this place!",
        "The app keeps crashing every time.",
        "Mediocre product, not worth the price."
    ],
    "label": [
        "positive", "negative", "neutral", "positive", "negative",
        "positive", "negative", "positive", "neutral", "negative",
        "positive", "negative", "positive", "negative", "neutral"
    ]
})

print(" Dataset Created Successfully\n")
print(data.head(), "\n")

data['clean_text'] = data['tweet'].str.lower()

vectorizer = TfidfVectorizer(max_features=1000, stop_words='english')
X = vectorizer.fit_transform(data['clean_text'])
y = data['label']

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42, stratify=y
)

model = MultinomialNB()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

print("Model Evaluation Results\n")
print("Accuracy:", round(accuracy_score(y_test, y_pred) * 100, 2), "%\n")
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred, labels=['positive', 'neutral', 'negative']))
print("\nClassification Report:\n", classification_report(y_test, y_pred, labels=['positive', 'neutral', 'negative']))


    </para>


</body>
</html>
